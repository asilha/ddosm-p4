Using the 'pure' switch: 

    ./veth.sh setup 8
    ./run.sh 

Using the 'mininet' environment: 

    ./mininet.sh 
    ./control.sh

Starting Several Wireshark Instances

    for i in {1..5..2}; do wireshark -i veth$i -k & done

General Parameters

    Training Length:     32 windows. 
    Window Size (m):    256 packets.
    Alpha:                0.078125
    K:                    3.5

    In control_rules.txt:

        register_write ingress.log2_m 0 8
        register_write ingress.training_len 0 32
        register_write ingress.alpha 0 20           20/256=0.078125
        register_write ingress.k 0 28               28/4=3.5

    In ddos.json: 

        "window_size": 256,

    In TCAD: 

        ../bin/tcad -t 32 -s 0.078125 -k 3.5


TCP Replay Parameters

    tcpreplay -q --limit=32768 --pps=256 -i s1-eth1  /media/p4/ddos/datasets/ddos5.pcap 2>&1

Using the 'ee' utility:

    time ../bin/ee -c ddos.json /media/p4/ddos/datasets/ddos5.pcap | ../bin/tcad -t 32 -s 0.078125 -k 3.5

Fixed-Point Representations

    Alpha   24.8    (/256) 
    K       29.3    (/8)
    Entropy	 28.4   (/16)
    Ewmmd	 14.18  (/2^18)

Synthetic Workload:

    Trafg takes a packet_count and generates:                               Volume     
        Training phase:                                                         
            packet_count/2 legitimate traffic                               1/3
        Detection phase:
            packet_count/4 legitimate traffic                               1/6
            packet_count/2 legitimate + malicious traffic:                  1/3
                malicious:         attack_proportion  * packet_count/2      
                legitimate:     (1-attack_proportion) * packet_count/2  
            packet_count/4 legitimate traffic                               1/6

    Timestamps in the synthetic workload ddos<proportion%>.txt files:
        Line 1: Beginning of the attack.
        Line 2: End of the attack. 

    Libpcap File Format https://wiki.wireshark.org/Development/LibpcapFileFormat
        Global header: 24 bytes
        Record header: 16 bytes

    Reverse-engineering the trafg-generated files: 

            Pcap record size:           68      bytes
                Record header:          16      
                Capture data:           52
                    Ethernet:               14
                    IPv4:                   20
                    Custom payload:         17
                        Timestamp               16 [Offset: 0x22-0x31]
                        Attack flag             01 [Offset: 0x32]
                    Ethernet:               01

            Total size:     13.369.344.024 bytes
            Global header:              24 bytes  
            Record area:    13.369.344.000 bytes
            # of records:      196.608.000 packets

            File ddos5.pcap split in 24 volumes with 8.192.000 packets each. 

            Phase       Packet Count    Start           End                Volume  Offset
            Total        196.608.000                                       24/24   00..23        
            Training:     65.536.000    13:03:00.000000 13:04:00.087231     8/24   00..07
            Detection 1:  32.768.000    13:04:00.087231 13:04:31.852544     4/24   08..11
            Detection 2:  65.536.000    13:04:31.852545 13:05:31.138658     8/24   12..19
            Detection 3:  32.768.000    13:05:31.138659 13:06:02.808079     4/24   20..23

            Window counts using m=2^18 packets per window.

            Phase       Window Count    Start           End                Volume  Offset
            Total                750                                       24/24   00..23        
            Training:            250    13:03:00.000000 13:04:00.087231     8/24   00..07
            Detection 1:         125    13:04:00.087231 13:04:31.852544     4/24   08..11
            Detection 2:         250    13:04:31.852545 13:05:31.138658     8/24   12..19
            Detection 3:         125    13:05:31.138659 13:06:02.808079     4/24   20..23

time ./ddosd-cpp/bin/ee -c ./ddosd-cpp/example/ddos.json ./ddos/datasets/synthetic/ddos5.pcap | ./ddosd-cpp/bin/tcad -t 250 -s 0.078125 -k 3.5 | tee ddos5.tcad.txt

Phase                            Time	            SrcEnt	    SrcMA   SrcMD   DstEnt	    DstMA	DstMD	Alarm
After trainining (t=250)        1459947840087230	   186    3056132    9672	   183    3000850    8007	0
After detection 1 (t=375)       1459947871852540	   186	  3059070	 8339	   183	  3007632	10234	0

Experiment: 

    a) Initialize with t=373 values. 

        register_write src_ewma 0 1600155
        register_write src_ewmmd 0 97985
        register_write dst_ewma 0 1575765
        register_write dst_ewmmd 0 105380

    b) Replay windows 374-383 to verify that detection still works. 
    c) We expect that at t=376 Defcon will be set to 1.
    d) We expect that at t=377 packet diversion will begin.  

Sources: 

    OWs 374-375: Volume 11, last 524288 packets. 
    OWs 376-383: Volume 12, first 2^3*2^18 = 2^21 = 2097152 packets

Commands to be used to generate the workload above: 

    editcap -r ddos5_00011.pcap ddos5_00011x.pcap 7667713-8192000
    editcap -r ddos5_00012.pcap ddos5_00012x.pcap 1-2097152
    mergecap -a -w ddos5_x.pcap ddos5_00011x.pcap ddos5_00012x.pcap 

Commands used to generate the workload for CMP182:

    PS D:\Downloads\P4\ddos\datasets\sample> 
    editcap -r ddos5_00012.pcap ddos5_00012a.pcap 1-262144
    editcap -r ddos5_00011.pcap ddos5_00011a.pcap 7929857-8192000
    mergecap -a -w ddos5_a.pcap ddos5_00011a.pcap ddos5_00012a.pcap


Custom Hash Functions in aclapolli-bmv2/targets/simple_switch/simple_switch.cpp:60 

    struct h1 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(155878125)*data + 144393013) % 179424691) % 976;
        }
        return hash;
    }
    };

    struct h2 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(113292259)*data + 68483982) % 179424691) % 976;
        }
        return hash;
    }
    };

    struct h3 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(35316782)*data + 126831809) % 179424691) % 976;
        }
        return hash;
    }
    };

    struct h4 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(159559853)*data + 107589136) % 179424691) % 976;
        }
        return hash;
    }
    };
    
    struct g1 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(81840042)*data + 13527551) % 179424691) % 2;
        }
        return hash;
    }
    };

    struct g2 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(19537968)*data + 97145494) % 179424691) % 2;
        }
        return hash;
    }
    };

    struct g3 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(50123735)*data + 142091935) % 179424691) % 2;
        }
        return hash;
    }
    };

    struct g4 {
    uint32_t operator()(const char *buf, size_t s) const {
        uint32_t hash = 0;
        if (s == 4) {
        uint32_t data = ntohl(*reinterpret_cast<const uint32_t*>(buf));
        hash = ((static_cast<uint64_t>(133965917)*data + 4784577) % 179424691) % 2;
        }
        return hash;
    }
    };

