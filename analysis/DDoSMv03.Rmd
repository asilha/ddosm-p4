---
title: "DDoS Attack Mitigation"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---
```{r setup, echo=FALSE, include=FALSE}

library(dplyr)
library(ggplot2)
library(readr)
knitr::opts_chunk$set(tidy=TRUE, tidy.opts=list(width.cutoff=60))

```

# Overview

```{r fn_tcad, include=FALSE}

read_tcad_trace = function(trace_file) {
  
  col_names = c("ts",
                "src_ent",
                "src_ewma",
                "src_ewmmd",
                "dst_ent",
                "dst_ewma",
                "dst_ewmmd",
                "alarm")
  
  col_types = "ciddiddl"

  tcad_trace = readr::read_table2(trace_file,
                       col_names = col_names,
                       col_types = col_types)

  tcad_trace = tcad_trace %>% tibble::rowid_to_column("ow")

  tcad_trace = tcad_trace %>% dplyr::mutate(src_ent   = src_ent/16,
                                 dst_ent   = dst_ent/16,
                                 src_ewma  = src_ewma/262144,
                                 dst_ewma  = dst_ewma/262144,
                                 src_ewmmd = src_ewmmd/262144,
                                 dst_ewmmd = dst_ewmmd/262144)  
  return(tcad_trace)
  
}

```

# Characterizing the Attack

What are our chosen k coefficients? 

Our experiments with **tcad_m_levels.py** show us candidate values for k, as follows: 

Log2(m) | k     | FPR
--------|-------|-----
13      | 4.000 | 1.8%
14      | 4.125 | 1.7%
15      | 4.250 | 1.8%
16      | 4.500 | 1.6%
17      | 4.750 | 1.6%
18      | 3.625 | 0.0%

TCAD measurements can be found in the following files: 

tcad_m_2_14_k_4.125.log
tcad_m_2_16_k_4.500.log
tcad_m_2_18_k_3.625.log

[Source: DDoS Mitigation.ipynb, section Finding TCAD Values]

## Entropy Overview

```{r read_tcad}

tcad_m14 = read_tcad_trace("~/p4sec/ddosm-p4/lab/ddos20/tcad_logs/tcad_m_2_14_k_4.125.log")
tcad_m16 = read_tcad_trace("~/p4sec/ddosm-p4/lab/ddos20/tcad_logs/tcad_m_2_16_k_4.500.log")
tcad_m18 = read_tcad_trace("~/p4sec/ddosm-p4/lab/ddos20/tcad_logs/tcad_m_2_18_k_3.625.log")

tcad_m14_k = 4.125
tcad_m16_k = 4.500
tcad_m18_k = 3.625

get_plot_tcad = function(tcad, k) {
  
  plot_options = list(  
    labs(x="OW number", y="Entropy"),
    geom_point(mapping=aes(y=src_ent), size=0.25, color="seagreen4"), 
    geom_point(mapping=aes(y=dst_ent), size=0.25, color="steelblue4"),
    geom_line(mapping=aes(y=src_ewma+k*src_ewmmd), color="seagreen4"),
    geom_line(mapping=aes(y=dst_ewma-k*dst_ewmmd), color="steelblue4"),
    theme_classic())

  plot = tcad %>% ggplot(mapping=aes(x=ow)) + plot_options
    
  return(plot)
}

get_plot_tcad(tcad_m14, tcad_m14_k) + labs(title="Entropy for each Observation Window")

```

## Entropy Under Attack

Alright, we have the graph. Now we need to focus in the attack (OWs 768-1280).

When we preinitialize training coefficients, the length of the workload is equal to the length of the detection phase.

For a detection phase of 2^24 packets we have: 

  2^(24-log2m-2) OWs before the attack,
  2^(24-log2m-1) OWs under attack, 
  2^(24-log2m-2) OWs after the attack.
  
For m=2^14, the detection phase has 2^(24-14)=2^10 windows: 
  
  2^8 OWs pre-attack and post attack,  
  2^9 OWs under attack, 

For m=2^16, 2^8 windows: 

  2^6 OWs pre-attack and post-attack,
  2^7 OWs under attack.
  
For m=2^18, 2^6 windows: 
  
  2^4 OWs pre-attack and post-attack,
  2^5 OWs under attack.

```{r}


# Function inputs are expressed in numbers of packets.
#   Log2d: Length of the detection phase, passed to trafg (as '-t 1048576', for instance).
#   Log2m: Length of the observation window, passed to tcad (as '-m 14', for instance)
# Function outputs are expressed in numbers of observation windows. 

detection = function(log2d, log2m) (2^(log2d - log2m))     
training  = function(log2d, log2m) (2^(log2d - log2m - 1)) # Training length = detection / 2 
attack    = function(log2d, log2m) (2^(log2d - log2m - 1)) # Attack length   = detection / 2
safety    = function(log2d, log2m) (2^(log2d - log2m - 2)) # Pre-attack and post-attack = attack / 4 (each)

attack_first = function(log2d, log2m) (training(log2d, log2m) + safety(log2d, log2m) + 1)
attack_last  = function(log2d, log2m) (training(log2d, log2m) + safety(log2d, log2m) + attack(log2d, log2m))

log2d = 24  
log2m = 14  
  
first = attack_first(log2d, log2m) + 1
last  = attack_last(log2d, log2m)

get_plot_tcad(tcad_m14 %>% filter(ow>=first, ow<=last), tcad_m14_k) + labs(title="Entropy for each Observation Window - Attack Phase")


```

# Mitigation Studies 

## Log2m = 14

### Parameters

```{r fn_mitigation}

log2m = as.integer(14)
m = as.integer(2^log2m)

log2d = as.integer(24)       # Where d is the total number of packets in the detection phase.  
d = as.integer(2^log2d)

training_length  = as.integer(2^(log2d - log2m - 1))   # We need to add this to the OW number when we skip training. 
detection_length = as.integer(2^(log2d - log2m))

get_ow = function(index, m) as.integer((index - 1) %/% m + training_length + 1) 

twos_complement = function(x) as.integer(ifelse(x > 32767, x - 65536, x))

```

### Loading

```{r dataset, include=FALSE}

# This is the format of the CSV files we import.
col_types = cols(
  src = col_character(),
  dst = col_character(),
  src_delta = col_character(),
  dst_delta = col_character(),
  attack = col_logical())

packets <- read_csv("~/p4sec/ddosm-p4/pcaps/ddos20m14b/if3_attack_out.csv", col_types = col_types)
```

### Preparing

#### Index

```{r}
packets = packets %>% tibble::rowid_to_column("index")
```

#### OW Number

```{r}
packets = packets %>% mutate(ow = get_ow(index,m)) 
```

#### Deltas

```{r}
# Convert from hexadecimal to decimal
packets = packets %>% mutate_at(vars(src_delta, dst_delta), funs(strtoi)) 

# Convert from 16-bit two's complement notation to integer. 
packets = packets %>% mutate_at(vars(src_delta, dst_delta), funs(twos_complement)) 

```

### Checking 

At this point we need to check whether we can observe the first attack packet. 

The attack occurs between windows (training_length + detection_length / 4 + 1) and (training_length + detection_length / 2). 

```{r}

attack_start = m * (detection_length / 4 + 1) + 1
attack_start

```

Querying the dataset at the given points.

```{r}

packets %>% filter(index >= attack_start - m)

```

For log2m=14, the attack begins at the fifth packet of OW 769 and lasts for a total of 512 OWs (i.e., OWs 769-1280). In OW 769 there is no packet diversion, since we have not set DEFCON yet. In OW 770 DEFCON is already set; the switch begins calculating deltas, using OWs 769 and 768 as a reference. 

## Typical Deltas

Question: for each OW, what are the typical frequency deltas (current OW - OW#768) for attack packets? 

```{r}

query = packets %>% 
  filter(ow>=first, ow<=last) %>% 
  group_by(ow, attack) %>% 
  summarize(q1=quantile(src_delta,0.25),
            q2=median(src_delta),
            q3=quantile(src_delta,0.75),
            iqr=IQR(src_delta),
            dq1=quantile(dst_delta,0.25),
            dq2=median(dst_delta),
            dq3=quantile(dst_delta,0.75),
            diqr=IQR(dst_delta))

query

```

Can we graph it? 

```{r}

dot_size = 2.0

query %>% 
  filter(ow<800) %>% 
  ggplot(mapping = aes(x=ow, shape=attack)) +
  geom_point(mapping = aes(y=q1), color="blue4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=q2), color="yellow4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=q3), color="orangered4", position="jitter", size=dot_size) 
  #coord_trans(y="log10")
  
query %>% 
  filter(ow>800) %>% 
  ggplot(mapping = aes(x=ow, shape=attack)) +
  geom_point(mapping = aes(y=q1), color="blue4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=q2), color="yellow4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=q3), color="orangered4", position="jitter", size=dot_size) #+
  #coord_trans(y="log10")

query %>% 
  filter(ow<800) %>% 
  ggplot(mapping = aes(x=ow, shape=attack)) +
  geom_point(mapping = aes(y=dq1), color="blue4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=dq2), color="yellow4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=dq3), color="orangered4", position="jitter", size=dot_size) 
  #coord_trans(y="log10")
  
query %>% 
  filter(ow>800) %>% 
  ggplot(mapping = aes(x=ow, shape=attack)) +
  geom_point(mapping = aes(y=dq1), color="blue4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=dq2), color="yellow4", position="jitter", size=dot_size) +
  geom_point(mapping = aes(y=dq3), color="orangered4", position="jitter", size=dot_size) #+
  #coord_trans(y="log10")
```

## Defining a threshold 

Let's set an arbitrary threshold and a function which indicates whether or not to divert a given packet. 

```{r fn_divert}

threshold = 16

#divert = function(src_delta, dst_delta) (src_delta >= threshold)
divert = function(src_delta, dst_delta) (dst_delta >= threshold)
#divert = function(src_delta, dst_delta) (src_delta >= threshold && dst_delta >= threshold)


```


## Address Counts

Get the stats for all but the first two OWs under attack: address counts for each delta value. 

```{r}

src_distinct = packets %>% filter(ow >= 770, ow <= 1280) %>% group_by(ow, attack, src_delta) %>% summarize(srcs=n_distinct(src))

src_distinct

src_distinct %>% 
  ggplot(mapping=aes(x=src_delta, y=srcs, color=attack)) +
  geom_line() +
  scale_color_manual(values=c("seagreen4", "orangered1"))
# + coord_cartesian(xlim=c(0,1500),ylim=c(0,4000))

```

```{r}

dst_distinct = packets %>% filter(ow >= 770, ow <= 1280) %>% group_by(ow, attack, dst_delta) %>% summarize(dsts=n_distinct(dst))

dst_distinct

dst_distinct %>% 
  ggplot(mapping=aes(x=dst_delta, y=dsts, color=attack)) +
  geom_line() +
  scale_color_manual(values=c("seagreen4", "orangered1"))
# + coord_cartesian(xlim=c(0,1500),ylim=c(0,4000))

```

## Classification Stats

Base Stats

```{r fn_stats}

stats = function() {
  
  true_evil = query %>% filter(attack==TRUE) %>% tally()
  true_good = query %>% filter(attack==FALSE) %>% tally()
  message("True evil: ", true_evil, " True good: ", true_good, " Total: ", true_evil + true_good)
  
  class_evil = query %>% filter(divert(src_delta,dst_delta)) %>% tally() 
  class_good = query %>% filter(!divert(src_delta,dst_delta)) %>% tally() 
  message("Class evil: ", class_evil, " Class good: ", class_good, " Total: ", class_evil + class_good)
  
  error_evil = query %>% filter(!divert(src_delta,dst_delta), attack==TRUE)  %>% tally() 
  error_good = query %>% filter(divert(src_delta,dst_delta), attack==FALSE) %>% tally() 
  
  message("FNcount: ", error_evil, " FPcount: ", error_good, " Total: ", error_evil + error_good)
  message("FNR: ", round(error_evil/true_evil,4), " FPR: ", round(error_good/true_good,4))  

}

```

```{r}

first = 770 
last = 1280 

query = packets %>% filter(ow>=first, ow<=last)

stats()

```

Confidence Intervals

```{r}
packets %>% 
  filter(ow>=first, ow<=last, attack==TRUE, divert(src_delta, dst_delta)==TRUE) %>% 
  group_by(ow) %>%
  summarize(n = n()) %>%
  summarize(mean = mean(n) / (0.2 * 16384), margin = qnorm(0.975) * sd(n)/sqrt(1280-770+1) / (0.2 * 16384))

```

```{r}
packets %>% 
  filter(ow>=first, ow<=last, attack==FALSE, divert(src_delta, dst_delta)==TRUE) %>% 
  group_by(ow) %>%
  summarize(n = n()) %>%
  summarize(mean = mean(n) / (0.8 * 16384), margin = qnorm(0.975) * sd(n)/sqrt(1280-770+1) / (0.8 * 16384))

```

## Classification Charts

It is interesting to observe what happens **over time**, OW after OW. 

```{r fn_graphs}

graph_true_good = function() query %>% filter(attack==FALSE) %>% summarize(n=n()) %>% ggplot(mapping=aes(x=ow,y=n)) + geom_point() + ggtitle("True Good")
graph_true_evil = function() query %>% filter(attack==TRUE)  %>% summarize(n=n()) %>% ggplot(mapping=aes(x=ow,y=n)) + geom_point() + ggtitle("True Evil")
  
graph_class_good = function() query %>% filter(diverted==FALSE) %>% summarize(n=n()) %>% ggplot(mapping=aes(x=ow,y=n)) + geom_point() + ggtitle("Forwarded")
graph_class_evil = function() query %>% filter(diverted==TRUE)  %>% summarize(n=n()) %>% ggplot(mapping=aes(x=ow,y=n)) + geom_point() + ggtitle("Diverted")
  
graph_false_neg = function() query %>% filter(!divert(src_delta,dst_delta), attack==TRUE)  %>% summarize(n=n()) %>% ggplot(mapping=aes(x=ow,y=n)) + geom_point() + ggtitle("False Negatives")
graph_false_pos = function()  query %>% filter(divert(src_delta,dst_delta), attack==FALSE) %>% summarize(n=n()) %>% ggplot(mapping=aes(x=ow,y=n)) + geom_point() + ggtitle("False Positives")

graph_results = function() 
  
  query %>% group_by(ow, attack, diverted) %>% summarize(n=n()) %>% 
    ggplot(mapping=aes(x=ow, y=n, color=attack, shape=diverted)) + 
    geom_point(position="jitter", size=2.0) + 
    #coord_cartesian(xlim=c(770,810),ylim=c(0,16384)) + 
    labs(x="Observation Window", y="Packet Count", title ="Classification Results") +
    scale_x_continuous(expand=expand_scale(add=0)) + 
    scale_y_continuous(expand=expand_scale(add=0)) +
    scale_color_manual(values=c("seagreen4", "orangered1")) + 
    theme_classic()  

```

```{r}

query = packets %>% 
  filter(ow>=first, ow<=last) %>% 
  mutate(diverted=divert(src_delta,dst_delta)) %>% 
  group_by(ow)

graph_true_good()
graph_true_evil()
graph_class_good()
graph_class_evil()
graph_false_neg()
graph_false_pos()
graph_results()




```

```{r}
mitigation_out = packets %>% 
  filter(ow>=first, ow<=last) %>% 
  mutate(diverted=(src_delta>=threshold)) %>% 
  group_by(ow, attack, diverted) %>% 
  summarize(n=n())

mitigation_out
```

If we analyze **only the first 30 OWs under attack**, with a threshold equal to 16, we divert ~86% of the attack, while keeping ~90% of the good traffic in the original path. 

## Log2m = 16

## Log2m = 18 

# Points to Ponder

For each OW, how many different attack sources are there? 

How are these deltas related to entropy?

What else can we do?

How do our findings correlate with TCAD measurements? 

```{r}
rm(query)
```

